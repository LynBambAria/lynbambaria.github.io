

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">

  <link rel="apple-touch-icon" sizes="76x76" href="/img/fluid.png">
  <link rel="icon" href="/img/fluid.png">
  

  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="LynBambAria">
  <meta name="keywords" content="">
  
    <meta name="description" content="HappyNewYear              * { margin: 0; padding: 0; box-sizing: border-box; user-select: none; }         body, html { width: 100%; height: 100%; overflow: hidden; background: #000; f">
<meta property="og:type" content="website">
<meta property="og:title" content="page.title">
<meta property="og:url" content="http://example.com/HappyNewYear/HappyNewYear.html">
<meta property="og:site_name" content="凛竹九歌.">
<meta property="og:description" content="HappyNewYear              * { margin: 0; padding: 0; box-sizing: border-box; user-select: none; }         body, html { width: 100%; height: 100%; overflow: hidden; background: #000; f">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2025-12-31T10:01:23.815Z">
<meta property="article:modified_time" content="2025-12-31T10:01:23.815Z">
<meta property="article:author" content="LynBambAria">
<meta name="twitter:card" content="summary_large_image">
  
  
    <meta name="referrer" content="no-referrer-when-downgrade">
  
  
  <title>page.title - 凛竹九歌.</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />





<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/c/font_1749284_5i9bdhy70f8.css">



<link rel="stylesheet" href="//at.alicdn.com/t/c/font_1736178_k526ubmyhba.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"example.com","root":"/","version":"1.9.8","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":true,"follow_dnt":true,"baidu":null,"google":{"measurement_id":null},"tencent":{"sid":null,"cid":null},"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false},"umami":{"src":null,"website_id":null,"domains":null,"start_time":"2024-01-01T00:00:00.000Z","token":null,"api_server":null}},"search_path":"/local-search.xml","include_content_in_search":true};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  

  

  

  

  

  



  
<meta name="generator" content="Hexo 5.4.2"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 60vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>凛玖.</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/" target="_self">
                <i class="iconfont icon-home-fill"></i>
                <span>首页</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/" target="_self">
                <i class="iconfont icon-archive-fill"></i>
                <span>归档</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/" target="_self">
                <i class="iconfont icon-category-fill"></i>
                <span>分类</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/" target="_self">
                <i class="iconfont icon-tags-fill"></i>
                <span>标签</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/" target="_self">
                <i class="iconfont icon-user-fill"></i>
                <span>关于</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/default.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="page.title"></span>
          
        </div>

        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      <div class="container nopadding-x-md">
        <div id="board"
          >
          
          <div class="container">
            <div class="row">
              <div class="col-12 col-md-10 m-auto">
                

<article class="page-content">
  <!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>HappyNewYear</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; user-select: none; }
        body, html { width: 100%; height: 100%; overflow: hidden; background: #000; font-family: 'Microsoft YaHei', sans-serif; }
        #container { position: relative; width: 100%; height: 100%; }
        #canvas { position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 1; }
        #blessings-container { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 2; }
        .blessing-bubble {
            position: absolute; padding: 12px 20px;
            background: linear-gradient(135deg, rgba(255,215,0,0.9), rgba(255,140,0,0.9));
            color: #fff; border-radius: 25px; font-size: 18px; font-weight: bold;
            text-shadow: 1px 1px 3px rgba(0,0,0,0.5);
            box-shadow: 0 5px 15px rgba(255,215,0,0.4);
            white-space: nowrap; transform: translate(-50%, -50%);
            animation: bubbleFloat 3s ease-out forwards; z-index: 10;
        }
        @keyframes bubbleFloat {
            0% { opacity: 0; transform: translate(-50%, 0) scale(0.8); }
            10% { opacity: 1; transform: translate(-50%, 0) scale(1); }
            90% { opacity: 1; }
            100% { opacity: 0; transform: translate(-50%, -100px) scale(0.8); }
        }
        #loading { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); color: #FFD700; font-size: 24px; z-index: 100; }
        #instructions { position: absolute; bottom: 20px; left: 0; width: 100%; text-align: center; color: rgba(255,255,255,0.7); font-size: 14px; z-index: 3; pointer-events: none; }
        #webgl-error { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); color: #FFD700; text-align: center; padding: 20px; background: rgba(10,5,24,0.9); border-radius: 10px; display: none; z-index: 200; }
        #webgl-error button { margin-top: 15px; padding: 8px 20px; background: #FFD700; color: #0A0518; border: none; border-radius: 20px; cursor: pointer; }
        
        @media (max-width: 768px) {
            .blessing-bubble { font-size: 16px; padding: 10px 16px; }
            #loading { font-size: 20px; }
        }
    </style>
</head>
<body>
    <div id="container">
        <canvas id="canvas"></canvas>
        <div id="blessings-container"></div>
        <div id="loading">加载中...</div>
        <div id="instructions">拖动鼠标/手指旋转视角 | 滚轮缩放</div>
        <div id="webgl-error">
            <p>浏览器不支持3D特效，请升级Chrome/Edge</p>
            <button onclick="location.reload()">重试</button>
        </div>
    </div>

    <script>
        // 100句新年祝福语
        const BLESSINGS = [
            "2026新年快乐！万事顺遂！",
            "新岁启封，奔赴新程！",
            "愿新年，胜旧年，有趣有盼！",
            "烟火起，照人间，举杯敬此年！",
            "2026，保持热爱，奔赴山海！",
            "所求皆如愿，所行皆坦途！",
            "岁岁常欢愉，年年皆胜意！",
            "新年到，福气到，好运连连！",
            "2026平安喜乐，得偿所愿！",
            "辞旧迎新，温柔留给自己！",
            "春风得意马蹄疾，2026创佳绩！",
            "家和万事兴，团圆乐融融！",
            "友谊如星光，岁岁相伴！",
            "前路浩浩荡荡，万事尽可期待！",
            "以岁月之名，祝你岁岁安澜！",
            "2026，被世界温柔以待！",
            "新年添喜气，万事皆顺意！",
            "乘风破浪，2026再创辉煌！",
            "三餐四季，温柔有趣！",
            "告别旧岁，2026闪闪发光！",
            "烟火向星辰，所愿皆成真！",
            "功不唐捐，2026终有收获！",
            "新年多喜乐，长安常安！",
            "愿我们的故事，新年更精彩！",
            "2026，日子清透，世事温柔！",
            "步步高升，财源广进！",
            "团团圆圆过新年，甜甜蜜蜜度新春！",
            "愿美好如期而至！",
            "2026心想事成，前程似锦！",
            "家人安康，岁岁相伴！",
            "友谊长存，温暖相伴！",
            "新年新气象，万事开门红！",
            "2026大展宏图，事业蒸蒸日上！",
            "阖家欢乐，幸福美满！",
            "辞旧迎新，一路繁花！",
            "旧愿皆已偿，新愿皆实现！",
            "感恩相遇，并肩前行！",
            "前程似锦绣，万事顺意！",
            "新年伊始，喜乐安宁！",
            "2026，不负韶华，不负自己！",
            "愿日子清透，万事顺意！",
            "春风得意，事事顺心！",
            "岁岁常欢愉，友谊永不渝！",
            "新年福气满，阖家皆平安！",
            "2026，温暖如初！",
            "好运连连，喜事天天到！",
            "所有努力都有回报！",
            "家和万事兴，幸福永相随！",
            "友谊岁岁年年不改变！",
            "2026，平安喜乐，诸事顺遂！",
            "乘风破浪，事业更上一层楼！",
            "幸福乐翻天，快乐永相伴！",
            "日子滚烫，来日方长！",
            "新岁有吉，万事兴龙！",
            "幸福到永久，快乐每一天！",
            "并肩走向更好的未来！",
            "万事皆顺心，幸福常相伴！",
            "美梦都实现，幸福永相随！",
            "职场顺风顺水，一路开挂！",
            "新年皆安，幸福常伴！",
            "光芒万丈，未来更辉煌！",
            "保持热爱，未来皆可期！",
            "不负努力，不负时光！",
            "年年皆胜意，岁岁都欢愉！",
            "把美好和温柔留给自己！",
            "加油向前，未来更精彩！",
            "年年无忧，幸福常伴！",
            "不负遇见，不负韶华！",
            "幸福到永久，快乐永相随！",
            "事业更辉煌，生活更美满！",
            "幸福乐无边，快乐每一天！",
            "梦想都开花，幸福常相伴！",
            "前程似锦绣，生活更精彩！",
            "快乐每一天，幸福永相随！",
            "情谊永不变，幸福常相伴！",
            "好运挡不住，喜事天天有！",
            "生活更美好，日子更红火！",
            "一路开挂向前冲！",
            "阖家安康，快乐永相随！",
            "不负时光，未来更美好！",
            "事事都称心，幸福常相伴！",
            "事事顺心如意！",
            "幸福永相随，好运天天见！",
            "生活更美好，快乐乐逍遥！",
            "未来皆美好，幸福常相伴！",
            "事事都发达，生活更精彩！",
            "快乐每一天，生活更美满！",
            "情谊永长存，幸福永相随！",
            "未来更美好，生活更幸福！",
            "幸福安康，生活更美满！",
            "前程更锦绣，生活更精彩！",
            "幸福美满，生活更精彩！",
            "万事顺意，幸福美满！",
            "生活更精彩，幸福常相伴！",
            "事业辉煌，生活更美好！",
            "快乐每一天，生活更美满！",
            "梦想都开花，幸福常相伴！",
            "生活更精彩，快乐永相随！",
            "幸福乐逍遥，生活更美好！",
            "前程更锦绣，事业更辉煌！",
            "日子更红火，生活更美满！",
            "温暖前行，幸福常伴！",
            "快乐每一天，生活更美好！",
            "不负自己，生活更精彩！",
            "快乐永相随，生活更美满！",
            "生活更美满，幸福常相伴！",
            "快乐每一天，生活更美好！",
            "幸福常相伴，生活更美好！",
            "光芒万丈，生活更美好！",
            "未来更辉煌，生活更美好！",
            "幸福常相随，生活更美好！",
            "不负时光，生活更精彩！",
            "快乐永相随，生活更美好！",
            "2026，一切都好，幸福到老！",
            "新年新起点，好运不间断！",
            "笑口常开，好运自然来！",
            "2026，平安喜乐，福气满满！"
        ];

        // 核心类（参考原代码结构，优化兼容和性能）
        class NewYear2026 {
            constructor() {
                // 核心变量
                this.scene = null;
                this.camera = null;
                this.renderer = null;
                this.particles = null;
                this.cakeParticles = [];
                this.fireworks = [];
                this.backgroundParticles = null;
                this.blessingElements = [];
                this.maxBlessings = 50;
                this.clock = new THREE.Clock();
                
                // 交互相关
                this.isDragging = false;
                this.previousPosition = { x: 0, y: 0 };
                this.cameraRotation = { x: 0, y: 0 };
                this.cameraDistance = 20;
                
                // 倒计时相关
                this.countdownNumbers = ['5', '4', '3', '2', '1', '2026'];
                this.currentCountdownIndex = 0;
                this.isCountdownFinished = false;
                
                // 数字点阵定义（复用参考代码的8x8点阵）
                this.digitPoints = this.initDigitPoints();
                
                // 初始化入口
                this.init();
            }

            // 初始化数字点阵
            initDigitPoints() {
                const digitGrids = {
                    '0': [[0,1,1,1,1,1,1,0],[0,1,0,0,0,0,1,0],[0,1,0,0,0,0,1,0],[0,1,0,0,0,0,1,0],[0,1,0,0,0,0,1,0],[0,1,0,0,0,0,1,0],[0,1,0,0,0,0,1,0],[0,1,1,1,1,1,1,0]],
                    '1': [[0,0,0,1,1,0,0,0],[0,0,1,1,1,0,0,0],[0,1,0,1,1,0,0,0],[0,0,0,1,1,0,0,0],[0,0,0,1,1,0,0,0],[0,0,0,1,1,0,0,0],[0,0,0,1,1,0,0,0],[0,1,1,1,1,1,1,0]],
                    '2': [[0,1,1,1,1,1,1,0],[0,0,0,0,0,0,1,0],[0,0,0,0,0,0,1,0],[0,0,0,0,0,1,0,0],[0,0,0,0,1,0,0,0],[0,0,0,1,0,0,0,0],[0,0,1,0,0,0,0,0],[0,1,1,1,1,1,1,0]],
                    '3': [[0,1,1,1,1,1,1,0],[0,0,0,0,0,0,1,0],[0,0,0,0,0,0,1,0],[0,0,1,1,1,1,1,0],[0,0,0,0,0,0,1,0],[0,0,0,0,0,0,1,0],[0,0,0,0,0,0,1,0],[0,1,1,1,1,1,1,0]],
                    '4': [[0,1,0,0,0,0,1,0],[0,1,0,0,0,0,1,0],[0,1,0,0,0,0,1,0],[0,1,1,1,1,1,1,0],[0,0,0,0,0,0,1,0],[0,0,0,0,0,0,1,0],[0,0,0,0,0,0,1,0],[0,0,0,0,0,0,1,0]],
                    '5': [[0,1,1,1,1,1,1,0],[0,1,0,0,0,0,0,0],[0,1,0,0,0,0,0,0],[0,1,1,1,1,1,1,0],[0,0,0,0,0,0,1,0],[0,0,0,0,0,0,1,0],[0,0,0,0,0,0,1,0],[0,1,1,1,1,1,1,0]],
                    '6': [[0,1,1,1,1,1,1,0],[0,1,0,0,0,0,0,0],[0,1,0,0,0,0,0,0],[0,1,1,1,1,1,1,0],[0,1,0,0,0,0,1,0],[0,1,0,0,0,0,1,0],[0,1,0,0,0,0,1,0],[0,1,1,1,1,1,1,0]],
                    '9': [[0,1,1,1,1,1,1,0],[0,1,0,0,0,0,1,0],[0,1,0,0,0,0,1,0],[0,1,1,1,1,1,1,0],[0,0,0,0,0,0,1,0],[0,0,0,0,0,0,1,0],[0,0,0,0,0,0,1,0],[0,1,1,1,1,1,1,0]]
                };
                
                // 补充2/0/6的点阵（适配2026）
                digitGrids['6'] = digitGrids['6'];
                digitGrids['2'] = digitGrids['2'];
                digitGrids['0'] = digitGrids['0'];
                
                const digitPoints = {};
                const gridSize = 8;
                
                // 生成每个数字的粒子位置
                Object.keys(digitGrids).forEach(digit => {
                    const points = [];
                    const grid = digitGrids[digit];
                    
                    for (let y = 0; y < gridSize; y++) {
                        for (let x = 0; x < gridSize; x++) {
                            if (grid[y][x] === 1) {
                                // 每个点生成5个粒子（增加密度）
                                for (let i = 0; i < 5; i++) {
                                    const px = (x - gridSize/2) * 0.5 + (Math.random() - 0.5) * 0.3;
                                    const py = (gridSize/2 - y) * 0.5 + (Math.random() - 0.5) * 0.3;
                                    points.push({x: px, y: py});
                                }
                            }
                        }
                    }
                    digitPoints[digit] = points;
                });
                
                return digitPoints;
            }

            // 初始化核心场景
            async init() {
                try {
                    // 1. 初始化Three.js核心组件
                    this.initScene();
                    this.initCamera();
                    this.initRenderer();
                    this.initLights();
                    
                    // 2. 创建背景和倒计时粒子
                    this.initBackground();
                    this.createBackgroundColorParticles();
                    await this.createCountdownParticles();
                    
                    // 3. 绑定交互事件
                    this.bindEvents();
                    
                    // 4. 开始倒计时和动画循环
                    document.getElementById('loading').style.display = 'none';
                    this.startCountdown();
                    this.animate();
                    
                } catch (err) {
                    console.error('初始化失败:', err);
                    document.getElementById('loading').style.display = 'none';
                    document.getElementById('webgl-error').style.display = 'block';
                }
            }

            // 场景初始化
            initScene() {
                this.scene = new THREE.Scene();
                this.scene.background = new THREE.Color(0x0a0a2a);
                this.scene.fog = new THREE.Fog(0x0a0a2a, 10, 100);
            }

            // 相机初始化
            initCamera() {
                this.camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 2000);
                this.updateCameraPosition();
            }

            // 更新相机位置（适配旋转/缩放）
            updateCameraPosition() {
                this.camera.position.x = Math.sin(this.cameraRotation.y) * Math.cos(this.cameraRotation.x) * this.cameraDistance;
                this.camera.position.z = Math.cos(this.cameraRotation.y) * Math.cos(this.cameraRotation.x) * this.cameraDistance;
                this.camera.position.y = Math.sin(this.cameraRotation.x) * this.cameraDistance;
                this.camera.lookAt(this.scene.position);
            }

            // 渲染器初始化（核心兼容修复）
            initRenderer() {
                const canvas = document.getElementById('canvas');
                this.renderer = new THREE.WebGLRenderer({
                    canvas: canvas,
                    antialias: true,
                    alpha: true
                });
                
                // 适配高清屏
                this.renderer.setSize(window.innerWidth, window.innerHeight);
                this.renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
                this.renderer.shadowMap.enabled = true;
                this.renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            }

            // 灯光初始化
            initLights() {
                // 环境光
                const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
                this.scene.add(ambientLight);
                
                // 定向光（金色主光）
                const directionalLight = new THREE.DirectionalLight(0xffd700, 1);
                directionalLight.position.set(10, 20, 5);
                directionalLight.castShadow = true;
                this.scene.add(directionalLight);
                
                // 点光源（暖光）
                const pointLight = new THREE.PointLight(0xff4500, 2, 100);
                pointLight.position.set(0, 10, 0);
                this.scene.add(pointLight);
            }

            // 星空背景
            initBackground() {
                const starGeometry = new THREE.BufferGeometry();
                const starCount = window.innerWidth > 768 ? 2000 : 1000;
                const starPositions = new Float32Array(starCount * 3);
                
                for (let i = 0; i < starCount * 3; i += 3) {
                    starPositions[i] = (Math.random() - 0.5) * 2000;
                    starPositions[i + 1] = (Math.random() - 0.5) * 2000;
                    starPositions[i + 2] = (Math.random() - 0.5) * 2000;
                }
                
                starGeometry.setAttribute('position', new THREE.BufferAttribute(starPositions, 3));
                const starMaterial = new THREE.PointsMaterial({
                    color: 0xffffff,
                    size: 1.5,
                    transparent: true,
                    opacity: 0.8
                });
                
                const stars = new THREE.Points(starGeometry, starMaterial);
                this.scene.add(stars);
            }

            // 彩色背景粒子（参考原代码）
            createBackgroundColorParticles() {
                const particleCount = window.innerWidth > 768 ? 1000 : 500;
                const geometry = new THREE.BufferGeometry();
                const positions = new Float32Array(particleCount * 3);
                const colors = new Float32Array(particleCount * 3);
                const velocities = [];
                
                for (let i = 0; i < particleCount; i++) {
                    const idx = i * 3;
                    // 随机位置
                    positions[idx] = (Math.random() - 0.5) * 200;
                    positions[idx + 1] = (Math.random() - 0.5) * 200;
                    positions[idx + 2] = (Math.random() - 0.5) * 200;
                    
                    // 随机彩色
                    const hue = Math.random() * 360;
                    const color = new THREE.Color().setHSL(hue/360, 0.8, 0.6);
                    colors[idx] = color.r;
                    colors[idx + 1] = color.g;
                    colors[idx + 2] = color.b;
                    
                    // 随机速度
                    velocities.push({
                        x: (Math.random() - 0.5) * 0.2,
                        y: (Math.random() - 0.5) * 0.2,
                        z: (Math.random() - 0.5) * 0.2
                    });
                }
                
                geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
                geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
                
                const material = new THREE.PointsMaterial({
                    size: 2,
                    vertexColors: true,
                    transparent: true,
                    opacity: 0.6,
                    blending: THREE.AdditiveBlending
                });
                
                this.backgroundParticles = new THREE.Points(geometry, material);
                this.scene.add(this.backgroundParticles);
                
                // 存储粒子数据用于动画
                this.bgParticlePositions = positions;
                this.bgParticleVelocities = velocities;
                
                // 启动背景粒子动画
                this.animateBackgroundParticles();
            }

            // 背景粒子动画
            animateBackgroundParticles() {
                if (!this.backgroundParticles) return;
                
                const positions = this.bgParticlePositions;
                for (let i = 0; i < this.bgParticleVelocities.length; i++) {
                    const idx = i * 3;
                    const velocity = this.bgParticleVelocities[i];
                    
                    // 更新位置
                    positions[idx] += velocity.x;
                    positions[idx + 1] += velocity.y;
                    positions[idx + 2] += velocity.z;
                    
                    // 边界反弹
                    if (Math.abs(positions[idx]) > 100) velocity.x *= -1;
                    if (Math.abs(positions[idx + 1]) > 100) velocity.y *= -1;
                    if (Math.abs(positions[idx + 2]) > 100) velocity.z *= -1;
                }
                
                this.backgroundParticles.geometry.attributes.position.needsUpdate = true;
                requestAnimationFrame(() => this.animateBackgroundParticles());
            }

            // 创建倒计时粒子（核心）
            createCountdownParticles() {
                return new Promise(resolve => {
                    const particleCount = window.innerWidth > 768 ? 3000 : 1500;
                    const geometry = new THREE.BufferGeometry();
                    const positions = new Float32Array(particleCount * 3);
                    const colors = new Float32Array(particleCount * 3);
                    const sizes = new Float32Array(particleCount);
                    
                    // 初始随机位置
                    for (let i = 0; i < particleCount * 3; i += 3) {
                        positions[i] = (Math.random() - 0.5) * 100;
                        positions[i + 1] = (Math.random() - 0.5) * 100;
                        positions[i + 2] = (Math.random() - 0.5) * 100;
                        
                        // 金色粒子
                        colors[i] = 1.0;     // R
                        colors[i + 1] = 0.84; // G
                        colors[i + 2] = 0.0;  // B
                        
                        sizes[i/3] = Math.random() * 2 + 1;
                    }
                    
                    geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
                    geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
                    geometry.setAttribute('size', new THREE.BufferAttribute(sizes, 1));
                    
                    const material = new THREE.PointsMaterial({
                        size: 2,
                        vertexColors: true,
                        transparent: true,
                        opacity: 0.9,
                        blending: THREE.AdditiveBlending,
                        sizeAttenuation: true
                    });
                    
                    this.particles = new THREE.Points(geometry, material);
                    this.scene.add(this.particles);
                    
                    // 存储初始/目标位置
                    this.originalPositions = positions.slice();
                    this.targetPositions = positions.slice();
                    
                    resolve();
                });
            }

            // 获取数字粒子位置（适配多位数）
            getNumberPoints(number) {
                const points = [];
                const digits = number.toString().split('');
                const spacing = 6; // 数字间距
                
                digits.forEach((digit, index) => {
                    const digitPoints = this.digitPoints[digit] || [];
                    digitPoints.forEach(point => {
                        points.push({
                            x: point.x + (index - (digits.length-1)/2) * spacing,
                            y: point.y
                        });
                    });
                });
                
                return points;
            }

            // 开始倒计时动画
            startCountdown() {
                const animateStep = () => {
                    if (this.currentCountdownIndex >= this.countdownNumbers.length) {
                        this.isCountdownFinished = true;
                        this.startFireworks(); // 启动烟花
                        
                        // 3秒后显示蛋糕+祝福语
                        setTimeout(() => {
                            this.showCake();
                            this.startBlessings();
                        }, 3000);
                        return;
                    }
                    
                    // 动画到当前数字
                    const number = this.countdownNumbers[this.currentCountdownIndex];
                    this.animateToNumber(number).then(() => {
                        setTimeout(() => {
                            this.currentCountdownIndex++;
                            animateStep();
                        }, 1000);
                    });
                };
                
                animateStep();
            }

            // 粒子动画到指定数字
            animateToNumber(number) {
                return new Promise(resolve => {
                    const positions = this.particles.geometry.attributes.position.array;
                    const numberPoints = this.getNumberPoints(number);
                    
                    if (numberPoints.length === 0) {
                        resolve();
                        return;
                    }
                    
                    // 分配目标位置
                    for (let i = 0; i < positions.length / 3; i++) {
                        const pointIndex = i % numberPoints.length;
                        const point = numberPoints[pointIndex];
                        
                        this.targetPositions[i * 3] = point.x;
                        this.targetPositions[i * 3 + 1] = point.y;
                        this.targetPositions[i * 3 + 2] = 0;
                    }
                    
                    // 缓动动画
                    const duration = 1500;
                    const startTime = Date.now();
                    
                    const animate = () => {
                        const elapsed = Date.now() - startTime;
                        const progress = Math.min(elapsed / duration, 1);
                        const easeProgress = 1 - Math.pow(1 - progress, 3); // 缓出
                        
                        // 更新粒子位置
                        for (let i = 0; i < positions.length; i += 3) {
                            positions[i] = this.originalPositions[i] + (this.targetPositions[i] - this.originalPositions[i]) * easeProgress;
                            positions[i + 1] = this.originalPositions[i + 1] + (this.targetPositions[i + 1] - this.originalPositions[i + 1]) * easeProgress;
                            positions[i + 2] = this.originalPositions[i + 2] + (this.targetPositions[i + 2] - this.originalPositions[i + 2]) * easeProgress;
                        }
                        
                        this.particles.geometry.attributes.position.needsUpdate = true;
                        
                        if (progress < 1) {
                            requestAnimationFrame(animate);
                        } else {
                            // 更新原始位置
                            this.originalPositions = positions.slice();
                            resolve();
                        }
                    };
                    
                    animate();
                });
            }

            // 显示蛋糕（参考原代码分层逻辑）
            showCake() {
                // 清理倒计时粒子
                if (this.particles) {
                    this.scene.remove(this.particles);
                    this.particles.geometry.dispose();
                    this.particles.material.dispose();
                    this.particles = null;
                }
                
                // 清理背景粒子
                if (this.backgroundParticles) {
                    this.scene.remove(this.backgroundParticles);
                    this.backgroundParticles.geometry.dispose();
                    this.backgroundParticles.material.dispose();
                    this.backgroundParticles = null;
                }
                
                // 创建蛋糕
                setTimeout(() => this.createCake(), 30);
            }

            // 创建分层蛋糕
            createCake() {
                // 三层蛋糕（不同颜色/尺寸）
                const cakeLayers = [
                    { radius: 8, height: 2, y: 0, color: 0xff6b6b },    // 底层红
                    { radius: 6, height: 2, y: 2.5, color: 0x4ecdc4 },  // 中层青
                    { radius: 4, height: 2, y: 5, color: 0x45b7d1 }     // 顶层蓝
                ];
                
                // 创建每层蛋糕
                cakeLayers.forEach(layer => this.createCakeLayer(layer.radius, layer.height, layer.y, layer.color));
                
                // 创建蜡烛
                this.createCandles();
                
                // ========== 关键修改：删除蛋糕文字创建调用 ==========
                // this.createCakeText(); 
            }

            // 创建蛋糕层
            createCakeLayer(radius, height, y, color) {
                const particleCount = window.innerWidth > 768 ? 800 : 400;
                const geometry = new THREE.BufferGeometry();
                const positions = new Float32Array(particleCount * 3);
                const colors = new Float32Array(particleCount * 3);
                
                for (let i = 0; i < particleCount; i++) {
                    const angle = Math.random() * Math.PI * 2;
                    const r = Math.sqrt(Math.random()) * radius;
                    const idx = i * 3;
                    
                    positions[idx] = Math.cos(angle) * r;
                    positions[idx + 1] = y + Math.random() * height;
                    positions[idx + 2] = Math.sin(angle) * r;
                    
                    // 层颜色
                    colors[idx] = (color >> 16 & 255) / 255;
                    colors[idx + 1] = (color >> 8 & 255) / 255;
                    colors[idx + 2] = (color & 255) / 255;
                }
                
                geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
                geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
                
                const material = new THREE.PointsMaterial({
                    size: 3,
                    vertexColors: true,
                    transparent: true,
                    opacity: 0.9,
                    blending: THREE.AdditiveBlending
                });
                
                const layer = new THREE.Points(geometry, material);
                this.scene.add(layer);
                this.cakeParticles.push(layer);
            }

            // 创建蜡烛（带闪烁动画）
            createCandles() {
                const candleCount = 6;
                for (let i = 0; i < candleCount; i++) {
                    const angle = (i / candleCount) * Math.PI * 2;
                    const radius = 2.5;
                    
                    const candleGeometry = new THREE.BufferGeometry();
                    const candlePositions = new Float32Array(100 * 3);
                    
                    for (let j = 0; j < 100; j++) {
                        const idx = j * 3;
                        candlePositions[idx] = Math.cos(angle) * radius + (Math.random() - 0.5) * 0.5;
                        candlePositions[idx + 1] = 7 + Math.random() * 3;
                        candlePositions[idx + 2] = Math.sin(angle) * radius + (Math.random() - 0.5) * 0.5;
                    }
                    
                    candleGeometry.setAttribute('position', new THREE.BufferAttribute(candlePositions, 3));
                    const candleMaterial = new THREE.PointsMaterial({
                        size: 2,
                        color: 0xffff00,
                        transparent: true,
                        opacity: 0.8 + Math.random() * 0.2,
                        blending: THREE.AdditiveBlending
                    });
                    
                    const candle = new THREE.Points(candleGeometry, candleMaterial);
                    this.scene.add(candle);
                    this.cakeParticles.push(candle);
                    
                    // 蜡烛闪烁动画
                    this.animateCandle(candle);
                }
            }

            // 蜡烛闪烁动画
            animateCandle(candle) {
                let time = 0;
                const originalSizes = [];
                const positions = candle.geometry.attributes.position.array;
                
                // 存储原始Y坐标
                for (let i = 1; i < positions.length; i += 3) {
                    originalSizes.push(positions[i]);
                }
                
                const animate = () => {
                    if (!candle.parent) return;
                    
                    time += 0.1;
                    const positions = candle.geometry.attributes.position.array;
                    
                    // 上下晃动
                    for (let i = 0; i < positions.length / 3; i++) {
                        const idx = i * 3 + 1;
                        positions[idx] = originalSizes[i] + Math.sin(time + i) * 0.3;
                    }
                    
                    candle.geometry.attributes.position.needsUpdate = true;
                    candle.material.opacity = 0.7 + Math.sin(time) * 0.3; // 亮度变化
                    
                    requestAnimationFrame(animate);
                };
                
                animate();
            }

            // ========== 关键修改：删除蛋糕文字相关方法 ==========
            // // 创建蛋糕文字（2026新年快乐）
            // createCakeText() { ... }

            // // 生成文字点阵
            // createTextPattern(text) { ... }

            // 启动烟花效果
            startFireworks() {
                // 每800ms生成一个烟花
                setInterval(() => this.createFirework(), 800);
                
                // 立即生成3个烟花
                for (let i = 0; i < 3; i++) {
                    setTimeout(() => this.createFirework(), i * 300);
                }
            }

            // 创建烟花（物理运动+淡出）
            createFirework() {
                const fireworkCount = 300;
                const geometry = new THREE.BufferGeometry();
                const positions = new Float32Array(fireworkCount * 3);
                const velocities = new Float32Array(fireworkCount * 3);
                const colors = new Float32Array(fireworkCount * 3);
                
                // 随机位置
                const x = (Math.random() - 0.5) * 100;
                const y = Math.random() * 30;
                const z = (Math.random() - 0.5) * 100;
                
                // 随机颜色
                const color = new THREE.Color();
                color.setHSL(Math.random(), 1, 0.7);
                
                // 初始化烟花粒子
                for (let i = 0; i < fireworkCount; i++) {
                    const idx = i * 3;
                    
                    // 初始位置
                    positions[idx] = x;
                    positions[idx + 1] = y;
                    positions[idx + 2] = z;
                    
                    // 随机速度
                    const speed = 0.5 + Math.random() * 1.5;
                    const phi = Math.random() * Math.PI * 2;
                    const theta = Math.random() * Math.PI;
                    
                    velocities[idx] = Math.sin(theta) * Math.cos(phi) * speed;
                    velocities[idx + 1] = Math.cos(theta) * speed;
                    velocities[idx + 2] = Math.sin(theta) * Math.sin(phi) * speed;
                    
                    // 颜色
                    colors[idx] = color.r;
                    colors[idx + 1] = color.g;
                    colors[idx + 2] = color.b;
                }
                
                geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
                geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
                
                const material = new THREE.PointsMaterial({
                    size: 2,
                    vertexColors: true,
                    transparent: true,
                    opacity: 1,
                    blending: THREE.AdditiveBlending
                });
                
                const firework = new THREE.Points(geometry, material);
                this.scene.add(firework);
                
                // 烟花物理动画
                const gravity = -0.01;
                const life = 2000;
                const startTime = Date.now();
                
                const animateFirework = () => {
                    const elapsed = Date.now() - startTime;
                    if (elapsed > life) {
                        // 清理烟花
                        this.scene.remove(firework);
                        geometry.dispose();
                        material.dispose();
                        return;
                    }
                    
                    const positions = firework.geometry.attributes.position.array;
                    
                    // 更新位置（重力+阻力）
                    for (let i = 0; i < fireworkCount; i++) {
                        const idx = i * 3;
                        
                        positions[idx] += velocities[idx];
                        positions[idx + 1] += velocities[idx + 1];
                        positions[idx + 2] += velocities[idx + 2];
                        
                        // 重力
                        velocities[idx + 1] += gravity;
                        
                        // 阻力
                        velocities[idx] *= 0.99;
                        velocities[idx + 1] *= 0.99;
                        velocities[idx + 2] *= 0.99;
                    }
                    
                    firework.geometry.attributes.position.needsUpdate = true;
                    material.opacity = 1 - (elapsed / life); // 淡出
                    
                    requestAnimationFrame(animateFirework);
                };
                
                animateFirework();
            }

            // 启动祝福语气泡
            startBlessings() {
                // 每30ms生成一个祝福
                setInterval(() => this.showRandomBlessing(), 30);
            }

            // 显示随机祝福语气泡
            showRandomBlessing() {
                // 限制最大数量
                if (this.blessingElements.length >= this.maxBlessings) {
                    const oldest = this.blessingElements.shift();
                    oldest && oldest.remove();
                }
                
                // 随机选择祝福
                const blessingText = BLESSINGS[Math.floor(Math.random() * BLESSINGS.length)];
                const bubble = document.createElement('div');
                bubble.className = 'blessing-bubble';
                bubble.textContent = blessingText;
                
                // 随机位置（避免边缘）
                const x = 10 + Math.random() * 80;
                const y = 10 + Math.random() * 80;
                bubble.style.left = `${x}%`;
                bubble.style.top = `${y}%`;
                
                // 随机大小
                const size = 0.8 + Math.random() * 0.4;
                bubble.style.transform = `translate(-50%, -50%) scale(${size})`;
                
                // 随机金色调
                const hue = Math.random() * 60;
                bubble.style.background = `linear-gradient(135deg, hsla(${hue}, 100%, 60%, 0.9), hsla(${hue + 20}, 100%, 50%, 0.9))`;
                
                // 添加到页面
                document.getElementById('blessings-container').appendChild(bubble);
                this.blessingElements.push(bubble);
                
                // 3秒后移除
                setTimeout(() => {
                    bubble.style.opacity = 0;
                    setTimeout(() => bubble.remove(), 300);
                    const index = this.blessingElements.indexOf(bubble);
                    index > -1 && this.blessingElements.splice(index, 1);
                }, 3000);
            }

            // 绑定交互事件（鼠标/触摸/缩放）
            bindEvents() {
                // 窗口适配
                window.addEventListener('resize', () => {
                    this.camera.aspect = window.innerWidth / window.innerHeight;
                    this.camera.updateProjectionMatrix();
                    this.renderer.setSize(window.innerWidth, window.innerHeight);
                });
                
                // 鼠标/触摸旋转
                const onPointerDown = (e) => {
                    this.isDragging = true;
                    this.previousPosition = {
                        x: e.clientX || e.touches[0].clientX,
                        y: e.clientY || e.touches[0].clientY
                    };
                };
                
                const onPointerMove = (e) => {
                    if (!this.isDragging) return;
                    
                    const currentX = e.clientX || e.touches[0].clientX;
                    const currentY = e.clientY || e.touches[0].clientY;
                    
                    const deltaX = currentX - this.previousPosition.x;
                    const deltaY = currentY - this.previousPosition.y;
                    
                    // 更新旋转角度
                    this.cameraRotation.y += deltaX * 0.01;
                    this.cameraRotation.x -= deltaY * 0.01;
                    this.cameraRotation.x = Math.max(-Math.PI/2, Math.min(Math.PI/2, this.cameraRotation.x));
                    
                    this.updateCameraPosition();
                    this.previousPosition = { x: currentX, y: currentY };
                };
                
                const onPointerUp = () => this.isDragging = false;
                
                // 绑定鼠标事件
                const canvas = document.getElementById('canvas');
                canvas.addEventListener('mousedown', onPointerDown);
                canvas.addEventListener('mousemove', onPointerMove);
                canvas.addEventListener('mouseup', onPointerUp);
                canvas.addEventListener('mouseleave', onPointerUp);
                
                // 绑定触摸事件
                canvas.addEventListener('touchstart', onPointerDown);
                canvas.addEventListener('touchmove', onPointerMove);
                canvas.addEventListener('touchend', onPointerUp);
                
                // 滚轮缩放
                canvas.addEventListener('wheel', (e) => {
                    e.preventDefault();
                    this.cameraDistance = Math.max(10, Math.min(50, this.cameraDistance + e.deltaY * 0.01));
                    this.updateCameraPosition();
                });
            }

            // 核心动画循环
            animate() {
                requestAnimationFrame(() => this.animate());
                
                const delta = this.clock.getDelta();
                
                // 旋转蛋糕粒子
                if (this.cakeParticles.length > 0) {
                    this.cakeParticles.forEach(particle => {
                        particle.rotation.y += delta * 0.2;
                    });
                }
                
                // 渲染场景
                this.renderer.render(this.scene, this.camera);
            }
        }

        // 页面加载完成后启动
        window.addEventListener('DOMContentLoaded', () => {
            // 动态加载Three.js（避免本地依赖）
            if (typeof THREE === 'undefined') {
                const script = document.createElement('script');
                script.src = 'https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js';
                script.onload = () => new NewYear2026();
                script.onerror = () => {
                    document.getElementById('loading').textContent = '加载失败，请刷新';
                    document.getElementById('webgl-error').style.display = 'block';
                };
                document.head.appendChild(script);
            } else {
                new NewYear2026();
            }
        });
    </script>
</body>
</html>

  

</article>



              </div>
            </div>
          </div>
        </div>
      </div>
    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
    <div class="statistics">
  
  

  
    
      <span id="busuanzi_container_site_pv" style="display: none">
        总访问量 
        <span id="busuanzi_value_site_pv"></span>
         次
      </span>
    
    
      <span id="busuanzi_container_site_uv" style="display: none">
        总访客数 
        <span id="busuanzi_value_site_uv"></span>
         人
      </span>
    
    

  

</div>

  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.4/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  <script  src="/js/local-search.js" ></script>

  <script defer src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
